% !TeX spellcheck = it_IT

\documentclass[format=169, 10pt]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{hyperref}
\usetheme{metropolis}

\usepackage{mathtools}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\title{Esercitazioni di Informatica B}
\subtitle{Riepilogo}

\author{Stefano Cereda\\
	stefano.cereda@polimi.it
}
\date{18/12/2018}
\institute[PoliMi]{\vspace{0.5cm}\centering Politecnico di Milano \\ \vspace{0.2cm}
	\includegraphics[width=0.2\textwidth]{../logopolimi}}

%\setbeamercovered{invisible}

\usepackage{xcolor}
\usepackage{listings}

% for matlab code
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}
%for c cide
\definecolor{mGreen}{rgb}{0,0.6,0}

\lstdefinestyle{matlab}{language=Matlab,%
	%basicstyle=\color{red},
	breaklines=true,%
	morekeywords={matlab2tikz},
	keywordstyle=\color{blue},%
	morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
	identifierstyle=\color{black},%
	stringstyle=\color{mylilas},
	commentstyle=\color{mygreen},%
	showstringspaces=false,%without this there will be a symbol in the places where there is a space
	numbers=left,%
	numberstyle={\tiny \color{black}},% size of the numbers
	numbersep=9pt, % this defines how far the numbers are from the text
	emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
	%emph=[2]{word1,word2}, emphstyle=[2]{style},    
}

\lstdefinestyle{CStyle}{
	backgroundcolor=\color{backgroundColour},   
	commentstyle=\color{mGreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{mGray},
	stringstyle=\color{mPurple},
	basicstyle=\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2,
	language=C
}

\makeindex


\begin{document}
	\begin{frame}
	\maketitle
\end{frame}

%1 gennaio
%2 febbraio
%3 febbraio
%3 gennaio
%2 gennaio

\begin{frame}{Acquisizione dati da fogli di calcolo}
La funzione \emph{xlsread} consente di aprire in MATLAB file .xls creati con Microsoft Excel.

Proviamo ad usarla.
\end{frame}

\begin{frame}[allowframebreaks, fragile]{Stazione ferroviaria - TdE 29 Gennaio 2018}
Si consideri il sistema di gestione dei treni in una stazione.
In ogni stazione ci sono al più $N\_BANCHINE$ e ogni banchina consente la sosta e il transito di un treno. Ad ogni treno in stazione viene assegnato uno dei seguenti stati:
\begin{itemize}
	\item \emph{fuoriStazione}: il treno, in attesa di essere assegnato a una banchina, si trova fuori dalla stazione
	\item \emph{inIngresso}: il treno è stato assegnato a una banchina ed è in marcia a velocità ridotta per entrare in stazione
	\item \emph{inSosta}: il treno è fermo a una banchina
	\item \emph{attesaOut}: il treno è fermo a una banchina in attesa di poter partire
	\item \emph{inUscita}: il treno sta abbandonando la banchina procedendo a velocità ridotta.
\end{itemize}

Si assuma che siano già stati introdotti i tipi $Stazione$ e $Banchina$ (si veda codice qui sotto). In particolare, $Stazione$ contiene l'insieme e il numero delle banchine presenti in stazione ($banchine$), la coda dei treni (al più 20) in attesa all'ingresso ($codaTreni$, $nTreniInCoda$) e una variabile Booleana che dice se c'e' qualche treno in manovra in stazione ($bloccata$).
$Banchina$, invece, contiene il numero della banchina e i dati del treno in sosta, se la banchina è in stato $occupato$. Ciascun treno, oltre ad avere il proprio stato e il numero della banchina eventualmente assegnata, ha un campo $minutiAttesaOut$ che indica da quanti minuti è in attesa in stato $attesaOut$.

\begin{lstlisting}[style=CStyle, basicstyle=\small]
#define N_BANCHINE 10
#define N_TRENI_CODA 20

typedef char stringa[20];
typedef enum { falso, vero } boolean;
typedef enum { libero, occupato } statoBanchina;
typedef enum 
{fuoriStazione, inIngresso, inSosta, attesaOut, inUscita} statoTreno;

typedef struct {
    stringa nome;
    statoTreno stTreno;
    int nBanchinaAssegnata;
    int minutiAttesaOut;
} Treno;

typedef struct {
    int numero;
    statoBanchina stBanchina;
    Treno trenoSosta;
} Banchina;

typedef struct {
    Banchina banchine[N_BANCHINE];
    int nBanchine; /* indica il numero di banchine presenti nella stazione */
    Treno codaTreni[N_TRENI_CODA];
    int nTreniInCoda;
    boolean bloccata;
} Stazione;
\end{lstlisting}

Si supponga che sia stata definita la variabile \emph{stazioneMI} di tipo \emph{Stazione} e che questa variabile sia stata riempita in modo opportuno per rappresentare lo stato corrente della stazione di Milano, si risponda alle seguenti richieste:
\begin{itemize}
\item Dichiarando tutte le variabili necessarie, si definisca un frammento di programma che determina e stampa l'indice (nell’array di banchine) della banchina in cui è in sosta il treno che è in attesa da più tempo di poter partire.
\item Si definisca un frammento di programma che, se la stazione non è bloccata dalle manovre di qualche treno e se vi è almeno un treno in coda per entrare in stazione, blocca la stazione, estrae dalla coda il primo treno che vi era stato inserito, gli assegna lo stato \emph{inIngresso}, e aggiorna la coda in modo tale che poi contenga solo i rimanenti treni in coda. Se per esempio, prima di questa operazione la coda è cosi costituita: stazioneMI.codaTreni[0] = FR2092, stazioneMI.codaTreni[1] = IR097, stazioneMI.codaTreni[2] = FA2673 (per semplicità abbiamo riportato solo il nome del treno, ma, ovviamente, codaTreni dovrebbe contenere l’intera struct corrispondente), dopo l’operazione si deve avere che stazioneMI.codaTreni[0] = IR097, stazioneMI.codaTreni[1] = FA2673.
\end{itemize}
\end{frame}


\begin{frame}[allowframebreaks]{Trading - TdE 16 Febbraio 2018}
Un’agenzia di trading online vuole memorizzare l’andamento del valore dei titoli che controlla.
La memorizzazione viene effettuata in \textbf{500} istanti temporali equidistanti.
I dati vengono salvati nel file MATLAB \textbf{log.mat} che contiene:
\begin{itemize}
\item la matrice \textbf{titoli}, le cui righe rappresentano i diversi titoli controllati e le cui colonne rappresentano i vari istanti in cui sono stati memorizzati i valori di tali titoli (quindi ogni cella della matrice contiene il valore di un titolo in un dato istante)
\item il vettore colonna \textbf{andamento}, con lo stesso numero di righe della matrice \textbf{titoli}, che contiene un valore numerico per ogni titolo, indicativo del suo andamento complessivo crescente o decrescente
\end{itemize}

\framebreak
\begin{enumerate}
\item Scrivere in linguaggio MATLAB una funzione \textbf{splittaMatrice} che:
\begin{itemize}
	\item riceva in input una matrice \textbf{titoliTot} (con la stessa struttura di \textbf{titoli}), un vettore \textbf{andamentoTot} (con stessa struttura di vettore \textbf{andamento}) e uno scalare \textbf{soglia};
	\item fornisca in output due matrici \textbf{titoliOver} e \textbf{titoliUnder} (ognuna con la stessa struttura di \textbf{titoliTot}). \textbf{titoliOver} include solo le righe di \textbf{titoliTot} corrispondenti agli elementi di \textbf{andamentoTot} con valore maggiore o uguale di soglia. \textbf{titoliUnder}, invece, include le righe di \textbf{titoliTot} corrispondenti agli elementi di \textbf{andamentoTot} con valore minori di soglia.
\end{itemize}

\framebreak
\item Scrivere in linguaggio MATLAB uno script che:
\begin{enumerate}
	\item legga dal file \textbf{log.mat} i due dati memorizzati: \textbf{titoli} e \textbf{andamento}
	\item richiami la funzione \textbf{splittaMatrice} per separare titoli nelle due matrici \textbf{titoliOver} e \textbf{titoliUnder}, per un valore di soglia pari a 0
	\item crei un vettore \textbf{x} che contenga i 500 istanti di memorizzazione 
	\item disegni su due grafici separati (che includano il titolo del grafico e il nome dei due assi) l’andamento dei titoli in \textbf{titoliOver} e \textbf{titoliUnder}, in funzione di x.
\end{enumerate}
\end{enumerate}
\end{frame}


\begin{frame}{Processi - Tde 16 Febbraio 2018}
Si assuma di avere un sistema operativo con un quanto di tempo di 25 ms e un processo P1 che riesce a decodificare 80 byte di segnale audio per ogni millisecondo di esecuzione.

Supponendo che una corretta riproduzione dell’audio richieda che vengano decodificati almeno 128 kbit/s, si risponda alle seguenti domande \textbf{giustificando le risposte}:
\begin{enumerate}
\item Se il processo P1 è l’unico attivo, può rispettare la velocità di codifica richiesta?
\item Supponiamo di attivare contemporaneamente a P1 altri 3 processi che abbiano lo stesso quanto di tempo e la stessa priorità di P1 e che ciascun cambio di contesto fra processi implichi un ritardo di 1 ms. Il processo P1 riuscirà a rispettare il limite richiesto per la corretta riproduzione?
\end{enumerate}
\end{frame}

\begin{frame}{Soluzione a Processi - Tde 16 Febbraio 2018}
\begin{enumerate}
    \item  Se P1 è l’unico attivo, avrà l’intera CPU per se, quindi potrà decodificare 80 * 8 * 1000 bit/s = 640 kbit/s; quindi può rispettare la velocità di codifica richiesta.
	\item Se sono attivi altri 3 processi, P1 non avrà l’intero tempo a disposizione, ma solo una parte di esso. In ogni secondo ci sono 1000 ms/(25+1) ms = 38 quanti di tempo circa che devono essere divisi tra i quattro processi. Se tutti hanno la stessa priorità e proseguono la loro esecuzione senza attendere dati dalle periferiche, ogni processo ha a disposizione 38/4=9 quanti di tempo circa. Quindi il nostro processo in un secondo decodificherà: 80 * 8 * 9 *25 bit/s = 144000 bit/s = 144 kbit/s, una quantità maggiore di quella minima richiesta. Di conseguenza, il nostro processo riuscirà a riprodurre correttamente l’audio. 
\end{enumerate}
\end{frame}

\begin{frame}{Binario - TdE 29 Gennaio 2018}
Un cardiopatico ha uno smartwatch con 48 byte di memoria liberi e vorrebbe tenere in memoria l’ECG relativo alla sua attività cardiaca durante la notte.
Il singolo dato è rappresentato dalla differenza di potenziale generata dal battito cardiaco (in Volt) ogni ora, e può essere un intero in intervallo [-1000 +2000] (estremi compresi).
Si assuma che lo smartwatch utilizzi una codifica in Complemento a 2 e si risponda alle seguenti domande:
\begin{enumerate}
\item  Quale è il numero B di bit necessari per registrare ogni singolo dato corrispondente a un’ora di attività cardiaca?
\item Quante ore è possibile registrare ancora nella memoria libera, supponendo che ciascuna cella di memoria possa contenere esattamente B bit? Quanta memoria è necessaria per tenere in memoria 128 ore?
\item Supponiamo ora che siano state registrate le differenze di potenziale generate dal battito cardiaco delle prime 2 ore della notte, e che queste siano [-135, -978]. Si codifichino questi numeri in Complemento a 2 con B bit e si calcoli la loro somma (in Complemento a 2), indicando se questa può essere registrata nello smartwatch, ovvero in B bit.
\end{enumerate}
\end{frame}

\begin{frame}[allowframebreaks]{Soluzione a Binario - TdE 29 Gennaio 2018}
\begin{enumerate}
\item $2^{10} = 1024 < 2000 < 2048 = 2^{11}$ 
Con B = 12 bit si riesce a coprire l’intervallo $[-2^{11}, 2^{11} - 1]$ e quindi si riesce a registrare l’attività cardiaca di un’ora. 
\item Essendo la memoria disponibile pari a 48 byte = 48 * 8 bit = 384 bit e poiché per ogni ora sono necessari 12 bit per tenere in memoria la rappresentazione della differenza di potenziale generata dal battito cardiaco, si possono tenere in memoria ancora al massimo 48 * 8 / 12 = 32 ore. Se si quadruplicasse la memoria (i.e. 48 * 4 = 192 byte) otterrei spazio sufficiente per 32 * 4 = 128 ore
\item  Tramite l’algoritmo delle divisioni successive $135_{10} = 10000111_2$, quindi il numero decimale $-135_{10}$ in codifica Complemento a 2 con B = 12 bit è $-135_{10} = 111101111001_{CP2}$. Dato che $978_{10} = 1111010010_2$, poichè -978 è negativo, devo cambiare  il valore di tutti i bit ottenuti e sommare 1 per trasformare tale codifica in un numero negativo in Complemento a 2 con B = 12 bit, ovvero $-978_{10} = 110000101110_{CP2}$. La somma di tali due valori rimane nell’intervallo di valori ammissibili con 12 bit, dunque è possibile registrare la somma delle differenze di potenziale generate dal battito cardiaco delle prime 2 ore della notte nello smartwatch.
\end{enumerate}
\end{frame}

\begin{frame}[allowframebreaks]{Cornici - TdE 29 Gennaio 2018}
Si consideri il seguente problema: si vuole creare una matrice quadrata che sia organizzata come quella in figura. 

\begin{tabular}{|c|c|c|c|c|}
	\hline 
	12 & 12 & 12 & 12 & 12 \\ 
	\hline 
	12 & 13 & 13 & 13 & 12 \\ 
	\hline 
	12 & 13 & 14 & 13 & 12 \\ 
	\hline 
	12 & 13 & 13 & 13 & 12 \\ 
	\hline 
	12 & 12 & 12 & 12 & 12 \\ 
	\hline 
\end{tabular} 

\begin{enumerate}
\item Si scriva in linguaggio MATLAB una funzione \alert{iterativa} \textbf{cornici} che, data la dimensione N della matrice e un numero di partenza P, restituisca al chiamante una matrice quadrata NxN così definita: la matrice contiene nella cornice più esterna il numero P e numeri crescenti nelle cornici più interne.

\item Si scriva inoltre uno script in linguaggio MATLAB che acquisisca da tastiera la dimensione desiderata N e il numero di partenza P, invochi la funzione \textbf{cornici} con gli opportuni parametri e infine stampi a video la matrice risultante.

\item Si implementi la funzione \alert{ricorsiva} \textbf{corniciRic} in modo che presenti lo stesso comportamento della funzione \textbf{cornici}
\end{enumerate}
\end{frame}






















\iffalse
\begin{frame}[fragile]{Matlab e binario}
\framebreak
Scrivere  una  funzione  Matlab  controllaCP2  che  prende  in  ingresso  una  stringa  (ad  
esempio ‘0101001’)  corrispondente  ad  un  numero  codificato  in  CP2  e  restituisce  due  
valori: 
\begin{enumerate}
	\item par  che  vale  true  se  il  numero  è  pari  e  false  altrimenti  
	\item    pos  che  vale  true  se  il  numero  è  positivo  e  false  altrimenti  
\end{enumerate}
(L’esecuzione  della  funzione  nel  caso  dell’esempio  darebbe  par = false  e  pos =
true)


\framebreak

La funzione matlab deve semplicemente controllare il bit a sinistra per sapere se il numero è positivo, ed il bit a destra per sapere se è pari (ragionate sul perché un numero positivo pari mantiene il primo bit=0 quando passo al negativo).
\begin{lstlisting}[style=matlab]
function [par, pos] = controllaCP2(stringa)
if stringa(1) == '0'
pos = true;
else
pos = false;
end
% versione equivalente:
% pos = stringa(1) == '0';

par = stringa(end) == '0';
end
\end{lstlisting}


\end{frame}



\begin{frame}[allowframebreaks]{Matlab - Ricorsione}
	Un metodo per calcolare il valore approssimato della radice quadrata di un
	numero reale non negativo z, detto metodo babilonese, utilizza la seguente
	relazione ricorsiva:
	\[x(n) = \frac{1}{2}(x(n-1)+\frac{z}{x(n-1)})\]
	\[x(0)=1\]
	
	Dove $n$ è un intero non-negativo arbitrario, mentre $x(n)$ rappresenta un'approssimazione della radice quadrata del numero $z$. Per esempio, se $z$ è pari a 2 e $n$ è pari a 3 il valore di $x(n)$ ottenuto applicando la formula indicata sopra è 1.4142 (che è una buona approssimazione della radice di 2).
	
	\framebreak
	
	L'errore di approssimazione associato a $x(n)$ è definito come segue:
	\[errore(n) = | x(n) - x(n-1)|\]
	e decresce al crescere di $n$. Per esempio, se si calcola la radice di 2 con $n$ pari a 1 si ottiene il valore 1.5000 con errore 0.5000. Se invece si calcola la radice dello stesso valore con $n$ pari a 2 si ottiene il valore 1.4167 con errore 0.0833.
	
	\framebreak
	
	\begin{enumerate}
		\item Si scriva una funzione ricorsiva \emph{sqrt1(z,n)} per MATLAB/Octave che
		restituisca un'approssimazione della radice quadrata di $z$ e il relativo errore utilizzando il metodo babilonese. Quando $n$ è pari a zero, si assuma un valore dell’errore pari a inf.
		\item Si scriva una funzione \emph{sqrt2(z,err)} per MATLAB/Octave che, utilizzando la funzione \emph{sqrt1}, restituisca un valore approssimato della radice quadrata di $z$ con errore non superiore al valore $err$ fornito come parametro.
	\end{enumerate}
	
	Nella soluzione di entrambi i quesiti non è permesso utilizzare alcuna funzione di
	libreria di MATLAB/Octave a parte la funzione \emph{abs(x)} per il calcolo del valore
	assoluto di x.
\end{frame}

\begin{frame}{Matlab - Grafici}
	Scrivere una funzione Octave con parametri $a$, $b$ e $p$ che esegue le seguenti operazioni:
	\begin{enumerate}
	\item  calcola i valori $\cos(x^2)$ per valori di x compresi fra a e b, con passo p, e li memorizza in un vettore y
	\item visualizza su un grafico l'andamento di y;
	\item restituisce al chiamante il massimo valore di $\cos(x^2)$ per $a \leq x \leq b$ ed il valore di x corrispondente. Per effettuare il
	calcolo in questione si può utilizzare la funzione max che, quando prende come parametro un vettore, restituisce due
	valori di cui il primo è il valore massimo trovato nel vettore ed il secondo è l’indice della posizione del vettore in cui tale
	valore è contenuto.
\end{enumerate}
\end{frame}


\begin{frame}{Matlab - Scomposizione in fattori}
	Scrivere una funzione che scomponga in fattori primi un numero.
	Il risultato dovrà composto da due vettori: il primo conterrà le basi dei fattori, il secondo conterrà gli esponenti dei fattori, cioè quante volte essi sono ripetuti.
	
	Esempio: il numero 100 è uguale a $2^2 * 5^2$, per cui il vettore delle basi sarà [2 5] mentre quello degli esponenti corrispondenti sarà [2 2].
	
	Un modo semplice per fattorizzare un numero consiste nel dividerlo ripetutamente per tutti i numeri che gli sono inferiori fino ad ottenere 1. 
\end{frame}
\fi

\end{document}